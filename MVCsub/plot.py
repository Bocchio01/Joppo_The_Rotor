import tkinter as tk
from traceback import print_tb

from MVCmain.ABC import ABCController
from Utils.TypingHint.settings import GUIType
from Utils.multiframetemplate import TwoFrameView

import serial
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from Utils.observable import Observable

N = 100
INTERVAL = 100


class PlotController:
    def __init__(self, main_controller: ABCController):
        self.main_controller = main_controller
        self.main_view = main_controller.view
        self.main_model = main_controller.model

        self.view = PlotView(
            master=self.main_view.root,
            opt=self.main_model.get_gui_opt()
        )
        self.model = PlotModel(controller=self)
        self.view.create_plot(self.model.fig)

        self.main_view.root.protocol("WM_DELETE_WINDOW", quit)

        self.model.port.addCallback(lambda e: self.start())

        self.view.quit_button.config(command=self.quit)

        self.view.R1_entry.bind(
            '<Return>',
            lambda e: self.model.update_R1(self.view.R1_entry.get())
        )

        self.view.R2_entry.bind(
            '<Return>',
            lambda e: self.model.update_R2(self.view.R2_entry.get())
        )

        self.view.arduino_port_entry.bind(
            '<Return>',
            lambda e: self.model.port.set(
                self.view.arduino_port_entry.get())
        )

    def start(self):
        if self.model.on_port_selected():
            self.animation = animation.FuncAnimation(
                self.model.fig,
                self.model.update,
                interval=INTERVAL
            )
            self.main_view.root.update()

    def quit(self):
        self.main_view.root.quit()
        self.main_view.root.destroy()


class PlotView(TwoFrameView):
    TAG = "Plotting Tab"

    def __init__(self, master: tk.Tk, opt: GUIType):

        TwoFrameView.__init__(self, master=master, opt=opt)

        self.title = tk.Label(
            master=self.left_frame,
            text="Study of an electric rotor",
            **opt['title_config']
        )

        self.info_label = tk.Label(
            master=self.left_frame,
            text="Simple app to graphicaly represent the voltage generated by a spinning rotor in cause of the magnetic field of a permanent magnet.",
            wraplength=350,
            justify=tk.LEFT,
            bg=opt['bg_general'],
            # **opt['text_config']
        )

        self.arduino_port_label = tk.Label(
            master=self.left_frame,
            text="Arduino port [COMx]:",
            **opt['text_config']
        )

        self.arduino_port_entry = tk.Entry(
            master=self.left_frame,
            # **opt['entry_config']
        )

        self.R1_label = tk.Label(
            master=self.left_frame,
            text="Resistance R1 [ohm]:",
            **opt['text_config']
        )

        self.R1_entry = tk.Entry(
            master=self.left_frame,
            # **opt['entry_config']
        )

        self.R2_label = tk.Label(
            master=self.left_frame,
            text="Resistance R2 [ohm]:",
            **opt['text_config']
        )

        self.R2_entry = tk.Entry(
            master=self.left_frame,
            # **opt['entry_config']
        )

        self.quit_button = tk.Button(
            master=self.left_frame,
            text="Close the app",
            **opt['button_config']
        )

        self.title.pack(fill=tk.X, pady=15)
        self.info_label.pack(fill=tk.X, pady=15)
        self.arduino_port_label.pack(pady=15, padx=15)
        self.arduino_port_entry.pack(fill=tk.X, padx=15)
        self.R1_label.pack(pady=15, padx=15)
        self.R1_entry.pack(fill=tk.X, padx=15)
        self.R2_label.pack(pady=15, padx=15)
        self.R2_entry.pack(fill=tk.X, padx=15)

        self.quit_button.pack(pady=50, side=tk.BOTTOM)

    def create_plot(self, figure):
        self.canvas = FigureCanvasTkAgg(figure, master=self.right_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)


class PlotModel:
    def __init__(self, controller):
        self.controller = controller
        self.port = Observable("")
        self.serial_port: serial.Serial
        self.R1 = 1
        self.R2 = 1

        self.fig, self.ax = plt.subplots()
        self.x = []
        self.y = []

    def update(self, frame):
        data = self.serial_port.readline().strip()
        if data == b'':
            return
        self.x.append(frame/INTERVAL*10)
        self.y.append(float(data) * ((self.R1 + self.R2) / self.R2))
        self.ax.clear()
        self.ax.plot(self.x, self.y)
        if len(self.x) > N:
            self.x.pop(0)
            self.y.pop(0)
        self.ax.relim()
        self.ax.autoscale_view()

        # Modify the font size and style of the tick labels
        for tick in self.ax.xaxis.get_major_ticks():
            tick.label.set_fontsize(10)
            tick.label.set_fontweight('bold')
        for tick in self.ax.yaxis.get_major_ticks():
            tick.label.set_fontsize(10)
            tick.label.set_fontweight('bold')

        self.fig.set_facecolor(
            self.controller.main_model.get_gui_opt()['bg_general']
        )

        self.ax.set_autoscale_on(True)
        self.ax.set_title(
            'Voltage generated by the spinning rotor',
            fontsize=14,
            fontweight='bold'
        )
        self.ax.set_xlabel('Time (s)')
        self.ax.set_ylabel('Voltage (V)')

    def on_port_selected(self):
        port = self.port.get()
        print(f"Port selected: {port}")
        try:
            self.serial_port = serial.Serial(port, 9600)

            print("Arduino connected!")
            return True
        except serial.SerialException:
            print("Error: port not found")
            return False

    def update_R1(self, R1):
        print(f"R1: {R1}")
        if R1 == "" or int(R1) <= 0:
            return
        self.R1 = int(R1)

    def update_R2(self, R2):
        print(f"R2: {R2}")
        if R2 == "" or int(R2) <= 0:
            return
        self.R2 = int(R2)
